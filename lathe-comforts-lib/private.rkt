#lang parendown racket/base

; lathe-comforts/private
;
; Implementation details.

;   Copyright 2011, 2017-2019 The Lathe Authors
;
;   Licensed under the Apache License, Version 2.0 (the "License");
;   you may not use this file except in compliance with the License.
;   You may obtain a copy of the License at
;
;       http://www.apache.org/licenses/LICENSE-2.0
;
;   Unless required by applicable law or agreed to in writing,
;   software distributed under the License is distributed on an
;   "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
;   either express or implied. See the License for the specific
;   language governing permissions and limitations under the License.


(require #/for-syntax racket/base)

(require #/for-syntax #/only-in syntax/parse
  expr expr/c id syntax-parse)

(require #/only-in racket/match match match/derived match-lambda)
(require #/only-in racket/contract/base -> any any/c)
(require #/only-in syntax/parse/define define-simple-macro)

(provide #/all-defined-out)



; ===== Evergreen utilities for binding syntax and FP ================


(module part1 racket/base
  
  (require #/for-syntax racket/base)
  (require #/for-syntax #/only-in syntax/parse syntax-parse)
  
  (require #/only-in syntax/parse
    ~or* ~peek-not ~seq define-splicing-syntax-class expr id pattern)
  (require #/only-in syntax/parse/define define-simple-macro expr id)
  
  (provide #/all-defined-out)
  
  
  ; === Utilities for binding syntax, part 1 ===
  
  (define-splicing-syntax-class binds
    #:attributes ([var 1] [val 1])
    (pattern
      (~or*
        ([var:id val:expr] ...)
        [(~seq var:id val:expr) ...]
        (~seq (~seq var:id val:expr) ...
          (~peek-not #/~seq _:id _:expr)))))
  
  
  ; === Utilities for functional programming, part 1 ===
  
  
  ; == Bindings and recursion, part 1 ==
  
  ; NOTE: We define this so it's easy to use something like
  ; `define-simple-macro` but with `syntax/loc`. If we don't use
  ; `syntax/loc` like this, stack traces which involve functions
  ; generated by the macro will use the source location of the macro,
  ; rather than the location where the macro was used.
  (define-simple-macro
    (define-simple-macro/loc (name:id pat:expr ...) body:expr)
    (define-syntax (name stx)
      (syntax-parse stx #/ (_ pat ...)
      #/syntax/loc stx
        body)))
  
  (define-simple-macro/loc (fn args:id ... body:expr)
    (lambda (args ...)
      body))
  
)
(require 'part1)
(require #/for-syntax 'part1)
(provide #/all-from-out 'part1)


; === Utilities for binding syntax, part 2 ===

(define-simple-macro
  (define-simple-normalizing-binder (name:id pattern:expr ...)
    (template:expr ...))
  (define-simple-macro/loc
    (name pattern ... vars:binds body:expr #/... ...)
    (template ... ([vars.var vars.val] #/... ...)
      body
      (... ...))))


; === Utilities for functional programming, part 2 ===


; == Bindings and recursion, part 2 ==

(define (pass arg func)
  (func arg))

(define-simple-normalizing-binder (w-)
  (let))

(define-simple-normalizing-binder (w-loop proc:id)
  (let proc))

(define-simple-macro/loc (loopfn proc:id args:id ... body:expr)
  (letrec ([proc (fn args ... body)])
    proc))


; == Conditionals ==

(define-simple-macro
  (mat subject:expr pattern:expr then:expr else:expr)
  (match subject [pattern then] [_ else]))

(define-simple-macro
  (expect subject:expr pattern:expr else:expr then:expr)
  (match subject [pattern then] [_ else]))

(define-simple-macro (matfns pattern:expr then:expr elsefn)
  #:declare elsefn (expr/c #'(-> any/c any) #:name "elsefn argument")
  (match-lambda [pattern then] [subject (elsefn.c subject)]))

(define-simple-macro (expectfn pattern:expr else:expr then:expr)
  (match-lambda [pattern then] [_ else]))

(define-syntax (dissect stx)
  (syntax-parse stx #/ (op subject:expr pattern:expr then:expr)
    #`(match/derived subject #,stx [pattern then])))

(define-syntax (dissectfn stx)
  (syntax-parse stx #/ (op pattern:expr then:expr)
    #`(lambda (subject)
        (match/derived subject #,stx
          [pattern then]))))
