Notes about the design of an alternative to Racket's generic interface system which allows objects to be merged, compared, and used as keys

(These notes start off with certain ideas and then restart and finally coalesce into something pretty solid. The point at which they start to coalesce is "Ah, no, we're just thinking about the extension wrong." We considered that this might be the subject of a whole new module system and a whole new way of defining types in conflict with Racket's traditions (in which case Rocketnia may have put these notes in her "Cronut" project), and we considered that this might be the subject of a whole new language not specifically tied to Racket, but it seems our ideas are meaningfully expressible as utility library functionality if we manage to find good nonoverlapping nomenclature for them.)



; monoids with a less intimidating name
best-effort-chainable-sys?
  chainable-sys-chain-list-maybe : (-> best-effort-chainable-sys? list? maybe?)

glossary? (imposes limits on how to implement best-effort-partially-comparable?, info-comparable?, capriciously-totally-comparable?, gen:equal-mode+hash, gen:dict)
  glossary-ref-maybe : (-> glossary? any/c maybe?)
  glossary-set-maybe : (-> glossary? maybe? glossary?)

capriciously-poppable-glossary? (extends glossary?)
  glossary-pop-capriciously-maybe : (-> capriciously-poppable-glossary? (maybe/c (list/c any/c capriciously-poppable-glossary?)))

best-effort-partial-order?
  partial-order-<=?-maybe : (-> best-effort-partial-order? any/c any/c (maybe/c boolean?))
  lub-chainable-sys : (-> best-effort-partial-order? best-effort-chainable-sys?)
  glb-chainable-sys : (-> best-effort-partial-order? best-effort-chainable-sys?)

best-effort-total-order? (extends best-effort-partial-order?)

best-effort-partially-comparable?
  get-intended-best-effort-partial-order : (-> best-effort-partially-comparable? best-effort-partial-order?)

info-comparable?
  get-info-best-effort-partial-order : (-> info-comparable? best-effort-partial-order?)

capriciously-totally-comparable?
  get-best-effort-total-order-capriciously : (-> capriciously-totally-comparable? best-effort-total-order?)

capriciously-poppable-glossary-sys?
  capriciously-poppable-glossary-sys-make-empty (-> capriciously-poppable-glossary-sys? capriciously-poppable-glossary?)

capriciously-poppable-keyish?
  capriciously-poppable-keyish-get-glossary-sys : (-> capriciously-poppable-keyish? capriciously-poppable-keyish-glossary-sys?)

capriciously-poppable-keyish-glossary-sys? (extends capriciously-poppable-glossary-sys? and capriciously-poppable-keyish?)

one-size-fits-all-glossary-sys : (-> capriciously-poppable-keyish-glossary-sys?)

total-order-glossary-sys : (-> best-effort-total-order? capriciously-poppable-keyish-glossary-sys?)

; A glossary system for things which prefer to be compared using `equal-always-hash/recur` and `equal-always?/recur`.
hash-glossary-sys : (-> capriciously-poppable-keyish-glossary-sys?)

trie-glossary-sys : (-> capriciously-poppable-keyish-glossary-sys?)

; TODO: Consider having a `...-comparable?` or `...-keyish?` interface where some keys superclass/subclass others and hence some keys can can designate partial components of the things other keys designate. (For any superclass/subclass relation that's an information ordering, we won't want this. If a key x is known to be less than two other distinct keys, then even though x == x, that fact isn't preserved by adding information to each of the x's. Hence, this kind of table would be only for non-information orderings.)

; TODO: Figure out the interface needed for things to be keys of a `trie-glossary-sys` glossary.


maybe we want

- given a value and an incomplete "any" type, maybe get its type (or rather, a partial implementation of the "any" type that only necessarily works on this value and makes at least a certain amount of progress on it)
- given a value, get a value representing its information lattice element
- given a value, maybe get a value representing its capriciously totally comparable element

Figuring out parametricity for <=:

The equality == relation for a type that has free type variable occurrences extends any corresponding set of relations that respect their own notions of equality. It's almost hard to imagine a relation that doesn't respect *some* notion of equality (but Prolog-style side effects might be just that kind of disrespect).

The subobject <= relation for a type that has free type variable occurrences extends any corresponding set of (what?) for those variables that respect their own notions of subobject relation?

Indeed, almost any relation respects *some* notion of one-way substitutability of its operands. We might have to account for the fact that certain relations, like <= itself, permit deep inference using >= derivations on their left-hand side and <= derivations on their right-hand side; relations have variances. Furthermore, some operands may evolve according not to <= or to >= but to (<= AND >=, i.e., ==) or to (<= OR >=, i.e., path-connectedness) or to (FALSE, i.e., Prolog-style side effects) or to (TRUE, i.e., the operand is ignored).

Huh. How do we actually use a <= definition to extend some relation decided later? Comparing by <= except at certain leaf nodes that compare according to the given relation actually does kinda the opposite of what we want there. There must be some kind of distributivity that makes that a sufficient implementation strategy for the == case but not the <= case.

Ah, no, we're just thinking about the extension wrong. Checking the relation on the leaf nodes *is* the whole point; what we accomplish with parametricity like this is to be able to say that the type we substitute in for a variable might itself be a dependent type, and the values this type depends on could have been in the same places in the data as the values of this type are.


Let the relation (Related : (T : Type -> Type) -> Functor T -> (A : Type) -> (B : Type) -> (C : A -> B -> Type) -> T A -> T B -> Type) be defined to be equivalent to (\T f A B C ta tb -> (tc : T ((a : A) * (b : B) * C a b)) * (ta === fmap @f (\(a * b * c) -> a) tc) * (tb === fmap @f (\(a * b * c) -> b) tc)), where === is information equality.

Generalized to relations with more or fewer than two operands (which we'll call "columns" here, or "cols" for short):

Let the relation (Related : (T : Type -> Type) -> Functor T -> (I : Type) -> (Cols : I -> Type) -> (RelatedCols : ((i : I) -> Cols i) -> Type) -> ((i : I) -> T (Cols i)) -> Type) be defined to be equivalent to (\T f I Cols RelatedCols tc -> (tr : T ((cols : (i : I) -> Cols i) * RelatedCols cols)) * ((i : I) => tc i === fmap @f (\(cols * r) -> cols i) tr)).


Our "any" type will be a lattice generated by all the possible interface types a value can implement. (Constructor definitions are just another kind of interface definition for this purpose.)

A makeshift value will consist of:

- Implementations of interfaces.

- Implementation opt-outs. This helps determine when makeshift values can merge together without creating overlaps.

- Attestations of equality on the overlaps the makeshift interface implementations (and opt-outs) may have with each other. (A constructor's interface usually overlaps with every other interface except the ones it opts out of overlapping with. Non-constructor interfaces usually overlap with nothing but constructor interfaces like those and any interfaces they opt into overlapping with (e.g., by defining their own implementation for values of a certain constructor, even if that constructor has opted out of overlapping).) In the best-behaved cases, overlapping can be statically ruled out, creating no need for equal overlap attestations. In the worst-behaved cases, the requirements for an equal overlap attestation are a simple "trust me on faith" even when they're wrong, creating no need for attestations in that case either. Attestations serve a purpose for cases somewhere in between those extremes.

- Attestations of equality on the overlaps the makeshift interface implementations may have with orphan instances in use.

- Conceptually, the full set of keys to these other collections so pass-through APIs can create modified imitations of the value (such as wrappers that blame a different module for errors). In a statically typed language, this will usually be static knowledge that can be enumerated in a type signature, but in some cases, a type signature may use record polymorphism to delegate part of this enumeration responsibility to the caller module. The presence of this information at run time helps us to imitate record polymorphism even without involving a static type system (or without the cooperation of a static type system that didn't anticipate our needs). In cases where even the whole program can't fully enumerate this information at compile time because it's truly dynamic, then the information arguably wasn't *meant* to leak through between modules at all, but we may nevertheless treat this run-time information as a way to explain the mechanism of debug inspectors and certain kinds of difficult-to-plug leaks that would otherwise be blamed on limitations of the implementation medium.

The elements of a distributive lattice that's free on certain generators can be represented as finite joins of irredundant finite meets of the generators. In this case, a makeshift value's contents correspond roughly to the collection of interface types participating in one of those finite meets, and a whole-program analysis can decompose the "any" type into a finite join of types like these, so there's a good chance we have something like a distributive lattice going on.

Joining the information of two values, to create a value of the type that's the meet of their individual types, may involve some extra work to attest the equality of their overlaps.

Taking the meet of the information of two values seems like it could make sense sometimes, but again this would involve some extra work to attest the equality of their overlaps, and that's a lot of work to do when either of the two values would already be an acceptable result by itself. The only reason I can think of that we would need something like this is because an attestation that A and B have equal overlap probably behaves something like the meet of A and B in its own right. Another possiblility is that the symmetry we're tempted to seek here is already entirely taken care of by the act of joining the information of two values; not only does joining values create a value of the meet of the interface types they implement, that value is also a value of the complement of the join of the interface types they opt out of.


To represent entities that span compile time and run time, we may want a compile-time interface that lets us extract the run-time delegate's expression and lets us insert another expression in its place. That way we can shuttle run-time values out of the lexical scope and back in again, allowing us to represent makeshift values as immediately-invoked constructor definitions that have a field for each free variable, and more generally allowing us to do this with other local struct definitions to implement their free variables too.


has-dynamic-type?
  ; Gets a representative of the dynamic type of the given value. The given dict is used as an environment for information that is only known to the whole program. In particular, it's consulted where this dynamic type's behavior can depend on how the "any" dynamic type behaves (e.g., if this type has a field of "any" type), which in turn depends on how all the other user-defined types in the program behave, so we have a `dynamic-type-var-for-any-dynamic-type` dict key that many dynamic types depend on this way.
  get-dynamic-type : (-> dict? has-dynamic-type? any/c)

dynamic-type-var-for-any-dynamic-type : (-> any/c)

knowable-predicate?
  knowable-predicate-get-accepts?-knowable :
    (-> knowable-predicate?
      (unconstrained-domain-> (knowable/c boolean?)))

smoosh-report?
  ; This says their join, i.e. how they smoosh as (lhs <= result) and (rhs <= result).
  smoosh-report-join-knowable-promise-maybe-knowable-promise : (-> smoosh-report? (promise/c (knowable/c (maybe/c (promise/c (knowable/c any/c))))))
  ; This says their meet, i.e. how they smoosh as (lhs >= result) and (rhs >= result).
  smoosh-report-meet-knowable-promise-maybe-knowable-promise : (-> smoosh-report? (promise/c (knowable/c (maybe/c (promise/c (knowable/c any/c))))))
  ; This says how they smoosh along ==, i.e. (<= and >=).
  smoosh-report-==-knowable-promise-maybe-knowable-promise : (-> smoosh-report? (promise/c (knowable/c (maybe/c (promise/c (knowable/c any/c))))))
  ; This says how they smoosh along the transitive closure of (<= or >=). If <= were an information ordering and lhs and rhs were the information lattice elements corresponding to two values a and b and the smooshing were to succeed (with a `just`), these two values would be known to be related by the tightest possible equivalence relation that was still loose enough to have its truth value preserved when the values a and b were replaced with other values for which additional information was known (i.e., (a <= a' and b <= b')). Conceptually, the bottom element in an information ordering (if it exists) is related to *every* element, so what we're going to do is not have a bottom element in ours -- at least not one that lets us *know* it's a bottom element. More generally, we're not going to let any two values have a value that's known to have less information than the both of them unless we want those two values to index the same entry in an information-equality-keyed table.
  smoosh-report-path-related-knowable-promise-maybe-knowable-promise : (-> smoosh-report? (promise/c (knowable/c (maybe/c (promise/c (knowable/c any/c))))))

smoosh-and-comparison-of-two-report?
  ; This says whether they're related as (lhs <= rhs).
  smoosh-and-comparison-of-two-report-<=?-knowable-promise : (-> smoosh-and-comparison-of-two-report? (promise/c (knowable/c boolean?)))
  ; This says whether they're related as (lhs >= rhs).
  smoosh-and-comparison-of-two-report->=?-knowable-promise : (-> smoosh-and-comparison-of-two-report? (promise/c (knowable/c boolean?)))
  smoosh-and-comparison-of-two-report-get-smoosh-report : (-> smoosh-and-comparison-of-two-report? smoosh-report?)

smooshable-dynamic-type?
  ; This obtains a predicate. However, the predicate can also be a flat-contract? to give better error messages when used as a contract, and it can also be a knowable-predicate? to allow a distinction between false-as-in-definitely-not and false-as-in-unknown.
  smooshable-predicate :
    (-> smooshable-dynamic-type? (-> any/c boolean?))
  smooshable-dynamic-type-get-smoosh-of-zero-report :
    (->
      smooshable-dynamic-type?
      ; Each report in the infinite sequence gives the smoosh identity elements, first for the type's bespoke notion of ordering, then for the information ordering, then for the information ordering of the information ordering representatives, and so on.
      (sequence/c smoosh-report?))
  smooshable-dynamic-type-get-smoosh-of-one-report :
    (->
      smooshable-dynamic-type?
      (smooshable/c _)
      (sequence/c smoosh-report?))
  smooshable-dynamic-type-get-smoosh-and-comparison-of-two-report :
    (->
      ; lhs type
      smooshable-dynamic-type?
      ; rhs type (usually dispatched to next, if this one can't fully determine the results)
      smooshable-dynamic-type?
      ; lhs
      (smooshable/c _)
      ; rhs
      (smooshable/c _)
      ; For each report in the infinite sequence, the next report says not only whether they smoosh along that one's == but also, only if they do, how their information ordering representatives smoosh along their information ordering.
      (sequence/c smoosh-and-comparison-of-two-report?))

; This gets another smooshable-dynamic-type? that applies to the information ordering representatives of the given one's elements.
smooshable-dynamic-type-get-info-smooshable-dynamic-type :
  (-> smooshable-dynamic-type? smooshable-dynamic-type?)

; A label is a symbol-like value that authors of libraries can coin. These are used as dynamic type tags. Someday we might allow authors to express that a label they coin isn't *necessarily* distinct from some other set of labels. This kind of hidden information would make it difficult to implement an efficient label-keyed dict though, so we don't support the full possibility space yet. Instead, we just allow `make-equal-always-label` labels for now, which are all either known to be equal or known to be nonoverlapping, but in the future, we might support more label constructors.
label?
  ; No methods.

; Makes a label that's known to be equal to any other make-equal-always-label label whose value is equal-always? to this one and known to be nonoverlapping with any other make-equal-always-label label whose value isn't equal-always? to this one.
make-equal-always-label : (-> any/c label?)

; Makes a dict that has label? values as keys.
make-label-dict : (-> dict?)

any-variant-labeled-dynamic-type?
  ; Returns a label which could, for instance, be used to look up this dynamic type's specific dict in the internals of an any-dynamic-type dict. (TODO: Improve this description.)
  any-variant-labeled-dynamic-type-get-variant-label-knowable :
    (-> any-variant-labeled-dynamic-type? (knowable/c label?))

key-report?
  ; Returns an empty immutable dictionary which allows any key satisfying the predicate (smooshable-predicate _) and compares keys by smooshing them along the transitive closure of (<= or >=).
  key-report-make-empty-dict-path-related-knowable : (-> key-report? (knowable/c dict?))
  ; Returns an empty immutable dictionary which allows any key satisfying the predicate (smooshable-predicate _) and compares keys by smooshing them along ==, i.e. (<= and >=).
  key-report-make-empty-dict-==-knowable : (-> key-report? (knowable/c dict?))

key-of-immutable-dict-dynamic-type? (must also implement smooshable-dynamic-type? and any-variant-labeled-dynamic-type?)
  ; For each report in the infinite sequence, the next report creates dicts that not only compare keys by whether they smoosh along that one's == but also, only if they do, smooshes their information ordering representatives along their information ordering.
  key-of-immutable-dict-dynamic-type-get-key-report :
    (-> key-of-immutable-dict-dynamic-type? (sequence/c key-report?))

key-of-mutable-dict-dynamic-type? (must also implement smooshable-dynamic-type? and any-variant-labeled-dynamic-type?)
  ; For each report in the infinite sequence, the next report creates dicts that not only compare keys by whether they smoosh along that one's == but also, only if they do, smooshes their information ordering representatives along their information ordering.
  key-of-mutable-dict-dynamic-type-get-key-report :
    (-> key-of-mutable-dict-dynamic-type? (sequence/c key-report?))

any-dynamic-type : (-> any/c)
  ; Besides just being an `any/c` value, the "any" dynamic type also implements:
  ;   - smooshable-dynamic-type?
  ;   - any-variant-labeled-dynamic-type?
  ;   - key-of-immutable-dict-dynamic-type?
  ;   - key-of-mutable-dict-dynamic-type?

; This allows other generic interfaces meant for dynamic types to declare default implementations for the "any" dynamic type that invoke their custom one.
any-dynamic-type? : (-> any/c boolean?)

make-empty-immutable-total-order-<=-based-dict : (-> (-> any/c any/c boolean?) dict?)

make-empty-mutable-total-order-<=-based-dict : (-> (-> any/c any/c boolean?) dict?)

; Returns an empty immutable dict where keys are looked up based on a sequence of key-part lookups. (They're looked up in the order the key-part dict constructors and key-part accessors are provided. Rearranging the order these are provided in may change the order of side effects during lookup and may change the iteration order of the resulting dict.)
make-empty-immutable-trie-dict : (-> (listof (list/c (-> dict?) (-> any/c any/c))) dict?)

make-empty-mutable-trie-dict : (-> (listof (list/c (-> dict?) (-> any/c any/c))) dict?)

; In most cases, new struct types that need to implement `key-of-...-dict-sys?` will use `make-empty-...-trie-dict` to account for all their fields separately (often using `any-dynamic-type` as the key-part dict constructor for each of the fields of type `any/c`). Many of the remaining atomic types will just use `make...-hashalw` or `make...-custom-hash`. Atomic types where it makes more sense to implement ordered indexing can use `make-empty-...-total-order-<=-based-dict`.

; Parametricity free theorems can be snuck into this (in a way that we bless by design) by observing that we can treat any two arbitrary Racket values as being "related" by some type's custom notion of == or <= just by considering them to be two representations for the same logical value of that type. Where we pass in a binding for `dynamic-type-var-for-any-dynamic-type` to `get-dynamic-type`, the dynamic type we pass in there can be one that understands "any" values as being equal according to this arbitrary relation, rather than the usual way that these representation values would be treated by the usual `any-dynamic-type`. Certain concepts like "the transitive closure of (<= or >=)" may not make sense if the relation we're sneaking in in such a way is heterogeneous, but nothing stops a sneaky user from just implementing those methods' results as being unknown.


How should we be able to merge contracted things? There seem to be a few states:

  - When the interface implementation is one of the clauses of a makeshift object expression, it definitely needs to be able to coexist with the other nonoverlapping clauses (and overlapping clauses with a specification of how the overlap works), and this could be thought of as a kind of immediate merging, if that frame of mind helps at all.

  - When the value is not given a contract yet and it was constructed in a way that lets some method calls dispatch to its merged peers, then it can be merged with other values according to their dispatching. For instance, a makeshift object expression where the set of implementations is a closed-world set does this kind of dispatching for method calls outside the set. A constructor result where the set of the constructor's implementations is a closed-world set does the same thing.

  - (When the value is exported from a module, the export's API signature masks the value and causes errors outside the mask, with the masked value considered to have the same or more information as than the unmasked one. The export's API signature expresses a lower bound on the API signature it can have in future versions of the module. Thus, passing the value or any of its outputs an input that defies this contract leads to behavior that must remain an error (not even a dispatch to orphan instances) until a future version of the module where it is given behavior.)

  - (When the value is imported by a module, the import's API signature masks the value and allows merging outside the mask, with the masked value considered to have potentially neither the same, less than, nor more information as the unmasked one.)

  - When the value is imported from another module and is thus given a contract by the export and another contract by the import, it can be merged with other values if the merging is performed within the importing module. This merging can only extend each value with each other in places where either the import contract is defied or (neither contract is defied and the original value definition allowed merging).

All right, so we are going to have yet another place to dispatch to: The merge peers. Dispatch for a method call might start by consulting the method invocation object, then dispatch from there to the method definition, then dispatch from there to the value, then dispatch from there to the constructor definition (or *each* constructor definition, for a merged value, expecting all but zero or one of them to eventually dispatch to its merge peers), then dispatch from there to the orphan instance in use for that constructor-method combination, then dispatch from that orphan instance to the value's other constructors (the "merge peers").


In practice, we have chosen not to implement the mutable dicts. If we need them, we're just going to model them as mutable boxes containing immutable dicts. If we need them to be more efficient than that, we'll tack on a mutable dict equivalent of the `glossesque-sys?` approach as an afterthought, and have our types that currently implement `prop:expressly-custom-gloss-key-dynamic-type` implement an analogous `prop:expressly-custom-mutable-gloss-key-dynamic-type` property alongside it.


## Yknow: Reconciling extensible behavior with library-update-reserved behavior for multiple dispatch

Our `...-via-second` double dispatch on smoosh operands involves some subtlety. A result can be as-yet unknown, but it can also be positively known to be unspecified. This way, a type definition can leave room for its future users' custom type definitions to specify the interaction instead, and the specified interaction can be safely combined with the known-unspecified result without fear that some future version of the library will make the known-unspecified result specified (unless the library simply breaks backwards compatibility).

This is just a simple form of dispatching to merge peers.

We do the merging in a helper function `dynamic-type-get-smoosh-and-comparison-of-two-reports` that invokes the two methods `dynamic-type-get-smoosh-and-comparison-of-two-reports-via-first` and `dynamic-type-get-smoosh-and-comparison-of-two-reports-via-second`. (TODO SMOOSH: Now that we're not doing this in the "any" type's method, see if we won't need `current-any-dynamic-type` to be a Racket parameter object.)

We've made a type `(yknow/c _)` that is like a `(promise/c (knowable/c (maybe/c (promise/c _))))`, except that joining the info of these values does the following:

  For the purposes of info smoosh joining values, it's like there's a NaN-style value and a two-level lattice:
  
    yknow unknown, representing that the library hasn't decided whether to provide this detail yet, or that the details we've tried to combine have not been info smoosh joinable
    yknow (known (just x))
    yknow (known nothing), the bottom element of the information lattice, representing that the library has decided not to provide this detail but to let it be provided in other places that are joined in
  
  Info smoosh joining works like so:
  
    (TODO: Do we want to define what happens with `yknow *` values that aren't wrapped in `info`? Maybe we can just treat them as failing with `unknown` for now.)
    info (yknow (known nothing)) + info (yknow (known *)) = info (yknow (known *))
    info (yknow (known (just x))) + info (yknow (known (just y))) = attempt `info x + info y` with allowance for failure; if it's `unknown` or `known nothing`, then this `+` operation fails, and attempting this `+` operation with allowance for failure gives `unknown`; if it's `known (just (info z))`, then this `+` operation gives `info (yknow (known (just z)))` (and attempting it with allowance for failure gives `known (just (info (yknow (known (just z)))))`)
    info (yknow unknown) + * = attempting this `+` operation always fails, and attempting it with allowance for failure gives `unknown`
      (If we defined this instead as `info (yknow unknown) + * = info (yknow unknown)`, then we might think of `yknow unknown` as the top element of the information lattice. However, that would be weird since `unknown` represents the least information.)
    (TODO: Do we want to define what happens with `info (info (yknow *))` values? Maybe we can just treat them as failing with `unknown` for now.)
  
  For comparison, `(knowable/c _)`:
  
    unknown, the bottom element *of the information lattice* (not of the by-design lattice)
    known x
  
    known x + known y = attempt `x + y` with allowance for failure; if it's `unknown` or `known nothing`, then this `+` operation fails, and attempting this `+` operation with allowance for failure gives `unknown`; if it's `known (just z)`, then this `+` operation gives `known z` (and attempting it with allowance for failure gives `known (just (known z))`)
    unknown + * = attempting this `+` operation always fails, and attempting it with allowance for failure gives `unknown`
    info unknown + info unknown = info unknown
    info unknown + info (known *) = info (known *)
    info (known x) + info (known y) = attempt `info x + info y`, and if that gives us `info z`, then `info (known z)`, or something like that
    (TODO: Do we want to describe what happens with `info (info (known *))` values?)


## Designing the object system

We're going to try to coexist seamlessly with Racket, which already has a couple of different notions of "interfaces" and "methods."

We'll use the following terminology:

We'll use "knack interface" as our term for a new kind of interface or protocol which can have zero or more methods, each of which can have zero or more arguments.

We'll use "invoke a knack method" as our term for invoking a method.

We'll use "knack invocation" as our term for a first-class method call object (possibly comprised of a knack interface name, a method name, callsite metadata, a lexical environment from which implicit arguments can be gleaned, and a bundle of explicit arguments, but not the target object).

We'll use "grip" for a first-class context object that's usually implicitly kept in the dynamic scope, and which can be consulted for certain method implementations that neither the method nor the target object knows about. These implementations correspond to what's known as "orphan instances" in Haskell. They may be thought of and derided as "ambient capabilities" in an object-capability security mindset, although we consider them to be the runtime service of the language, and we'll still take lessons from object-capability security and think of "capabilities" as separate first-class objects that serve as highly special-purpose gatekeepers to the service. It can also be thought of as the set of effect handlers that's currently in force. Another way to think of this is that it's simply the "dynamic scope." In some projects, I've referred to this bundle of orphan instances as the "specialization matrix" (by appeal to the geometry of the Expression Problem, with interface types on one axis of a 2D grid and concrete types on the other) or as the "perm" or "permit" (the bundle of permissions for side effects). Since this object in some sense represents a running program's access to the outside world and to its own set of code that has survived the dead code elimination process, we could potentially refer to it as the "WPI" ("World Programming Interface"), as the "affordance" the world provides the program, or as the "provisioning" or "loadout" of the program. Along the lines of "affordance," we've presently chosen "grip," basically in the sense of "grip on reality." It's a nice short term that can evoke ideas of both perception and control.

We'll use "canny data type" as our term for a user-defined concrete type that can be instantiated and supports knacks. It may have zero or more constructors, each of which may have zero or more fields.

We'll use "pact" and the naming convention `_____/p` to refer to our own contract system inspired by Racket's, suitable for documenting our objects. (These terms are our off-brand variants of "contract" and `_____/c`, respectively.) A pact will usually attenuate a value `x` by replacing it with a value `y` such that `x` and `y` pass an info <= check in the contract system. (Sometimes computing the actual info <= check can give an unknown result, but the pact system will still conceptually preserve the information ordering relation that info <= checks approximate.)

A Racket value that supports our object system will have certain knack interfaces and canny constructors it innately knows that it has the presence or absence of support for. "Support" for a canny constructor means that it can be deconstructed and put back together again in a round trip that preserves everything we know about its info {==, <=, >=, join, meet, and path-related} smooshability.

Where the smooshability is unknown, round-tripping has some leeway, so it's possible for a value to differ in some observable behavior after one of these round trips. An observable behavior that can differ like this is one we'll consider suitable for use only in debugging and optimization situations.

We'd like the pact system to be able to specify whether it's asserting every detail about a value or just asserting some of the details. Racket's contract systems seem to be unprincipled about this, with `->` contracts preserving `prop:evt` but `evt/c` contracts not preserving `prop:procedure`, although `evt/c` seems like an exception to the usual trend. Since we'd like to be able to ensure that clients of a module's API aren't relying on undocumented details, we'll tend to consider pacts to hide away everything except the functionality they directly describe, unless otherwise specified.

  - `(constructor a b c)`
    - constructs a value which has its details specified by the `constructor` constructor's implementation, which determines whether the value is known to be (or not to be) round-trippable through any given constructor, or known to have (or not to have) any given knack interface
      - typically (but not always), the value is known to be fully round-trippable through the `constructor` constructor and known not to be fully round-trippable through any other constructors of the same algebraic data type by the same author or upstream authors; and when this is the case, typically (but not always), the constructor doesn't leave anything known-unspecified, since the round-trippability support might not be prepared to preserve any particular additional info that's been merged into the known-unspecified parts of a value
  - `match (constructor a b c)`
    - matches a value which is known to be fully round-trippable through the `constructor` constructor, and otherwise asserts that the value is known not to be fully round-trippable through that constructor
  - `dissect (constructor a b c)`
    - asserts the value is known to be fully round-trippable through the `constructor` constructor
  - `(constructor/p a/p b/p c/p)`
    - equivalent to `(etc-ignoring/p (constructor/p ...))`; i.e., asserts the value is known to be round-trippable through the given constructor in a way that abides by the given contracts; creates an attenuated value which still has this property, and which replaces the status of other knack interfaces and canny constructor round-trippabilities with known absences (and only successfully creates this value if the constructor's implementation deems that this attenuated value is possible to create without interfering with its round-trippability)
  - `(makeshift knack ...)`
    - constructs a value which is known to have the given knack interface but is not known not to have others, is not known to be fully round-trippable through any particular constructor, and is only known not to be round-trippable through any particular constructor if that constructor's implementation overtly excludes the knack interface
  - `(knack/p ...)`
    - equivalent to `(etc-ignoring/p (knack/p ...))`; i.e., asserts the value is known to have the given knack interface in a way that abides by the given contracts; creates an attenuated value which still has this property, and which replaces the status of other knack interfaces and canny constructor round-trippabilities with known absences
  - `(etc-preserving/p (knack-1/p ...) (knack-2/p ...) (constructor-1/p ...) (constructor-2/p ...) (not/p negated-knack-1?) (not/p negated-knack-2?) (not/p negated-constructor-1?) (not/p negated-constructor-2?) ...)`
    - asserts the value is known to have all of the given knack interfaces in ways that abide by the given contracts, known to be round-trippable through each of the given constructors in ways where the field values abide by the given contracts, and known not to have the given negated knack interfaces and not to be round-trippable through the given negated canny constructors; creates an attenuated value which still has these properties, and which preserves the present, absent, unknown, or known-unspecified status of other knack interfaces and canny constructor round-trippabilities of the value
  - `(etc-ignoring/p (knack-1/p ...) (knack-2/p ...) (constructor-1/p ...) (constructor-2/p ...) (not/p negated-knack-1?) (not/p negated-knack-2?) (not/p negated-constructor-1?) (not/p negated-constructor-2?) ...)`
    - like `etc-preserving/p`, but creates an attenuated value which has a known absence of any knack interface or canny constructor round-trippability other than the ones either specified here or implied by the asserted constructors' implementations (and only successfully creates this value if the asserted constructors' implementations have consensus that this attenuated value is possible to create without interfering with their round-trippability, or if there are no asserted constructors here whose round-trippability we need to concern ourselves with); when a value is exported through this contract, the known absence is reported as a usage error (and possibly represented as an unknown result), and when a value is imported through this contract, the known absence is reported as known-unspecifiedness the user can potentially use for merging imports
  - `(etc-obviating/p (knack-1/p ...) (knack-2/p ...) (constructor-1/p ...) (constructor-2/p ...) (not/p negated-knack-1?) (not/p negated-knack-2?) (not/p negated-constructor-1?) (not/p negated-constructor-2?) ...)`
    - like `etc-ignoring/p`, but also asserts the value already has a known absence of any knack interface or canny constructor round-trippability other than the ones either specified here or implied by the asserted constructors' implementations


## Further along

After the object system is built, we can define specific knack interfaces that represent different specific ways a macro can be used.

Then we can define a way to import multiple special-purpose definitions of a macro or function while merging them all into a single abstraction.

Then, with those mergeable abstraction interfaces, we can define alternative ways of calling macros and functions that don't execute them immediately but instead obtain a bundle of their code and the code of their transitive dependencies, in a program representation that we can translate to multiple other programming languages. This is the main goal of the Cene project, and in this fashion, we can approach it seamlessly and incrementally within Racket.
